<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>canvas</title>
  <style>
    body {
      margin: 0;
    }

    #myCanvas {
      width: 99vw;
      /* height: calc(100vh - 105px); */
      border: 1px dashed pink;
    }

    #warp {
      width: 100vw;
      height: 100px;
      display: flex;
      align-items: center;
    }
  </style>
</head>

<body>
  <div>
    <div class="warp">
      <textarea type="text" cols="50" id="userInputField"></textarea>
      <button id="btn">下载</button>
    </div> 
    <!--1159.5 2217 -->
    <canvas id="myCanvas" width="1159.5px" height="2300px"></canvas>
  </div>
</body>
<script>

  // 获取Canvas元素和其上下文
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');

  // dpr = window.devicePixelRatio || 1,
  //         bsr = ctx.webkitBackingStorePixelRatio ||
  //               ctx.mozBackingStorePixelRatio ||
  //               ctx.msBackingStorePixelRatio ||
  //               ctx.oBackingStorePixelRatio ||
  //               ctx.backingStorePixelRatio || 1

  // 用户输入的文字
  let bg, userInput;
  const TextAlign = {
    CENTER: 'center',
    LEFT: 'left',
    RIGHT: 'right',
  };
  let fontName = 'myfont';


  // 创建一个可下载的链接
  function downloadCanvasImage(canvas, filename = 'output.png') {
    // 将Canvas内容转换为data URL
    const dataUrl = canvas.toDataURL('image/png');

    // 创建隐藏的可下载链接
    const link = document.createElement('a');
    link.download = filename;
    link.href = dataUrl;

    // 触发点击事件来下载
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }


  document.getElementById('userInputField').addEventListener('input', (event) => {
    userInput = event.target.value;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(bg, 0, 0, 1080, 1920);
    drawText(
      userInput,
      700,
      'Arial',
      74,
      lineSpacing = 0,
      color = 'white',
      strokeText = false,
      align = 'center',
    )
  });

  document.getElementById('btn').addEventListener('click', (event) => {
    downloadCanvasImage(canvas, `text-image-${Date.now()}.png`);

  })

  /**
   * Measures the width of a string for a given font.
   * @param {string} text
   * @param {IFont} font
   * @returns {number}
   */
  function getTextWidth(text, font) {
    const testContext = document.createElement('canvas').getContext('2d');
    testContext.font = getCanvasFontProperty(font);

    return testContext.measureText(text);
  }

  /**
   * For a given string, returns a new string in which all the separate words (characters divided by a space) fit in the given width. Can add spaces into original words if they are too long.
   * @param {string} text
   * @param {number} availableWidth
   * @param {IFont} font
   * @returns {string}
   */
  function splitIntoFittingWords(text, availableWidth, font) {
    const splitResults = [];
    // text = text.trim();

    text.split(' ').forEach(word => {
      if (getTextWidth(word, font).width < availableWidth) {
        // word fits
        splitResults.push(word);
      } else {
        // word does not fit, split into characters
        groupText(word, '', availableWidth, font).forEach(entry => {
          splitResults.push(entry);
        });
      }
    });

    return splitResults.join(' ');
  }

  /**
   * Breaks up a string into lines that fit within the supplied width.
   * @param {string} text
   * @param {number} width
   * @param {string} fontName
   * @param {number} fontSize
   * @returns {string[]}
   */
  function fitText(text, width, fontName, fontSize) {
    const font = createFont(fontName, fontSize);
    const fittingWords = splitIntoFittingWords(text, width, font);

    return groupText(fittingWords, ' ', width, font);
  }
  /**
  * Groups a given string into fitting parts. What a part is is defined by the character to split the original string on.
  * @param {string} text
  * @param {string} splitOn
  * @param {number} availableWidth
  * @param {IFont} font
  * @returns {string[]}
  */
  function groupText(text, splitOn, availableWidth, font) {
    return text.split(splitOn).reduce((resultingLines, currentItem) => {
      if (resultingLines.length === 0) {
        resultingLines.push('');
      }
      const lastLine = resultingLines[resultingLines.length - 1];

      // test if the last line with the current word would fit
      const testLine = (lastLine.length > 0 ? lastLine + splitOn : lastLine) + currentItem;
      const testLineWidth = getTextWidth(testLine, font).width;
      if (
        testLineWidth > availableWidth &&
        !(resultingLines.length === 1 && resultingLines[0].length === 0)
      ) {
        // does not fit, create new line
        resultingLines.push(currentItem);
      } else {
        // add to current line
        resultingLines[resultingLines.length - 1] = testLine;
      }

      return resultingLines;
    }, []);
  }


  const createFont = (name, size) => ({ size, name });

  function getCanvasFontProperty(font) {
    return `${font.size}px ${font.name}`;
  }

  function drawText(
    text,
    width,
    fontName,
    fontSize, //number
    lineSpacing = 0,
    color = 'white',
    strokeText = false,
    align = 'center',
    topOffset = 160,
    leftOffset = 0,
    paraSpacing = 40,
  ) {

  
    let isPara = /\p/s.test(text)
    let paras = [];
    if (isPara) {
      paras = text.split('\p');
    } else {
      paras = [text];
    }
    

    const alignModes = [TextAlign.LEFT, TextAlign.CENTER, TextAlign.RIGHT];
    if (alignModes.indexOf(align) === -1) {
      throw new Error(`Invalid alignMode (possible options: ${alignModes.join(',')})`);
    }

    // for now, just add spacing to fix fonts falling ut of view sometimes (at the bottom specifically)
    // padding will be removed by trimming canvas at the end
    const padding = { x: 20, y: fontSize * 2 }; // todo this needs a better fix

    const font = createFont(fontName, fontSize);

    // create and init canvas
    const canvas = document.getElementById('myCanvas');
    const context = canvas.getContext('2d');


    context.font = getCanvasFontProperty(font);

    context.textAlign = align;
    context.textBaseline = 'top';
    context.fillStyle = color;
    context.strokeStyle = color;

    // draw lines
    let yOffset = topOffset;
    let baseX = leftOffset;
    switch (align) {
      case TextAlign.RIGHT: {
        baseX += canvas.width - padding.x;
        break;
      }
      case TextAlign.LEFT: {
        baseX += padding.x;
        break;
      }
      case TextAlign.CENTER: {
        baseX += canvas.width * 0.5;
        break;
      }
    }

    let cursor = {
      x: canvas.width * 0.5,
      y: yOffset,
    };

    let tempLines;
    for (let i = 0; i < paras.length; i++) {
      let isWrap = /\r?\n/s.test(paras[i])
      if (isWrap) {
        tempLines = paras[i].split('\r\n')
      }
      else {
        tempLines = [paras[i]]
      }
      if(i!=0) {
        yOffset += paraSpacing;
      }
      for(let j = 0; j < tempLines.length; j++) {
        let lines = fitText(tempLines[j], width - 2 * padding.x, fontName, fontSize);

        lines.forEach(line => {
          if (strokeText) {
            context.strokeText(line, baseX, yOffset);
          } else {
            context.fillText(line, baseX, yOffset);
          }

          cursor = {
            x: canvas.width * 0.5 + 0.5 * getTextWidth(line, font).width,
            y: yOffset,
          };

          yOffset += (fontSize + lineSpacing);
        });
      }
    }

  }


  const loadImg = (url) => {
    return new Promise(function (resolve, reject) {
      const image = new Image();
      image.onload = function () {
        resolve(image);
      };
      image.onerror = function (error) {
        reject(error);
      };
      image.src = url;
    });
  };

  const loadFont = (url) => {
    return new Promise(function (resolve, reject) {
      const font = new FontFace(fontName, `url(${url})`, {
        style: "normal",
        weight: "400",
      });
      font.load().then(() => {
        resolve(font);
      }, (error) => {
        reject(error);
      });
    });
  };

  function addFontFace(fontFamily, fontUrl) {
    const fontFace = document.querySelector('style');
    fontFace.innerHTML += `@font-face {
    font-family: "${fontFamily}";
    src: url("${fontUrl}") ;
  }`;

  }

  const imgUrl = './bg.jpg';
  const fontUrl = 'FZYTK.ttf';
  addFontFace(fontName, fontUrl);

// reset to use built-in font
//FangSong STFangsong
fontName = 'cursive';

  userInput =`        
         三\r\n
即便身强体壮\r\n
也别轻易投身事务\r\n
就算思维敏捷\r\n
也不合适去改变什么\r\n
青年的责任在于\r\n
待在家里看书自省\r\n
\p
外面路铺好了又挖，\r\n
噪音震天，车辆鸣笛横行，\r\n
还是岁月静好，草长莺飞？\r\n
都没有关系\r\n
青年的义务在于\r\n
始终如一地看清\r\n
\p
战火在地球仪的角落点燃\r\n
阵亡人数是无关痛痒的数字\r\n
有人黑色头巾下掩面哭泣，\r\n
有人穿着节日礼服欢庆街头\r\n
发生什么就发生吧，\r\n
青年们喜爱静心\r\n
\p
世界无时无刻不在变化\r\n
茫然地跟在众人身后\r\n
或许依然赶不上潮流\r\n
就这样吧，安于现状吧`
  
  Promise.all([loadImg(imgUrl), loadFont(fontUrl)])
    .then(results => {
      const [img, font] = results;

      bg = img;
       
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      // ctx.fillStyle = 'rebeccapurple'; 
      // ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawText(
        userInput,
        1030, //700
        fontName,
        54, //80 71
        lineSpacing =34,
        color = 'white',
        strokeText = false,
        align = 'left',
        topOffset = 100,
        leftOffset = 240,
        paraSpacing = -40, //66
      )

    })
    .catch(error => {
      console.error(error);
    });


</script>

</html>
